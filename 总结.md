## 1.Vue核心
###  01_初试vue
1. root容器里的代码依然符合html规范，只是加入了一些Vue语法
2. root容器里的代码称为【Vue模板】
3. 容器跟Vue实例是一一对应的
4. 真实开发中只有一个Vue实例，会配合组件一起使用
5. {{xxx}}中的xxx要写表达式，且xxx可以自动读取data中的所有属性
6. 一旦data中的数据发生改变，页面中用到该属性的地方也会自动更新

-  区别：表达式 、 js代码
   1. 表达式的定义：一个表达式会生成一个值，可以放在任何一个需要值的地方（表达式有返回值）
          (1) a
          (2) a + b
          (3) x === y ? true : false
    
    1. js代码（是语句，也包括表达式）
          (1) if(){}
          (2) for(){}
          (3) function(){}


### 02_Vue模板语法
  vue模板语法有两大类：
   1. 插值语法
        功能：用于解析元素体里的内容
        写法：{{xxx}}，xxx是js表达式，也可以直接读取data中拥有的属性
   2. 指令语法
        功能：用于解析标签（包括：标签属性，绑定事件，标签内容...）
        写法：:href='xxx'，xxx同样是表达式


### 03_数据绑定
vue中有两种数据绑定方式：
  1. 单项绑定(v-bind)：数据只能从data流向页面
  2. 双向绑定(v-model)：数据不但可以从data流向页面，还可以从页面流向data
     - 备注: 
        1. 双向绑定只能绑定到表单应用上(input，select，checked等)
        2. v-model:value可以简写成v-model，因为v-model默认收集的就是value值


### 04_MVVM模型
   1. MVVM模型：
      1. M (Model): 模型 : data中的数据
      2. V (View): 视图 : 模板代码
      3. VM (ViewModel): 视图模型 : Vue实例
   2. 发现：
      1. data中的所有数据，最后都会出现在vm身上
      2. vm身上所有的属性方法 及 Vue实例原型上的所有属性，在Vue模板中都可以直接使用


### 05_数据代理
   1. Vue中的数据代理
      - 通过vm对象来代理_data中的属性的操作 （读/写）
   2. Vue中数据代理的好处
      - 更加方便的操作data中的数据
   3. 基本原理
      1. 在vm身上绑定_data中的属性
      2. 给添加到vm身上的属性绑定Object.defineProperty的getter和setter
      3. 通过getter和setter对_data中的数据进行操作（读/写）


### 06-1_事件处理
事件的基本使用:
  1. 事件要配置在methods中，最后也会跑到vm上
  2. methods中的函数，都是被Vue管理的函数，this指向的是vm 或 组件实例对象
  3. @click='demo' 和 @click='demo($event)'一样,但后者可以传值


### 06-2_事件修饰符
  - 常用: 
    1. prevent: 阻止事件默认事件
    2. stop: 阻止事件冒泡
    3. once: 事件只执行一次

  - 不常用:
    4. capture: 使用事件的捕获模式
    5. self: 只有event.target是当前元素的时候才触发事件
    6. passive: 事件的默认行为先触发，在执行回调函数

*修饰符可以一次添加多个*


### 06-3_键盘事件
   1. Vue提供的常用键盘别名
     回车 => enter
     删除 => delete
     推出 => esc
     换行 => tab (特殊，要用keydown事件绑定)
     上 => up
     下 => down
     左 => left
     右 => right

   2. 其他按键的绑定方式： @keyup.e.key（按键名字）
    - 注意: 如果是多个单词(CapsLock)，需要写成 @keyup.caps-lock

   3. Vue.config.keyCodes.自定义键名 = 键码，可以自定义按键别名

*键盘别名可以一次添加多个*


**如果input上既有v-model也有事件，会先执行事件，在执行v-model**

**如果data中的数据发生改变，Vue会重新解析模板，如果插值表达式中用到了methods里的方法，Vue就会重新加载这个方法，保证值是最新的**


### 07_计算属性
   计算属性:
     1.定义: 属性不存在，是根据已有属性计算得来的
     2.原理: 根据Object.defineproperty提供的getter和setter
     3.getter什么时候被调用:
        （1）初次调用计算属性时
        （2）计算属性中依赖的属性发生改变的时候
     4.优点: 跟methods方法实现相比，计算属性有缓存，可以复用，效率更高，测试方便
     5.备注:
        （1）计算属性最终的值会放在vm上，可以直接调用
        （2）如果计算属性被修改，需要用到set
        （3）简写，如果确定计算属性只读不改，可以使用计算属性


### 08_监听属性
   1. 监听属性:
      1. 当被监听的属性发生变化时，回调函数被调用
      2. 监听的属性存在，才能进行监听！！（不存在也不会报错）
      3. 监听属性可以监听vm身上的所有属性（包括计算属性）
      4. 写法
       （1）在实例中添加watch配置
       （2）在vm.$watch('属性',{})进行监听

   2. 深度监听:
      1. vue可以监听多级属性变化
      2. vue中的watch默认不能监听多级属性变化
      3. 使用watch可以根据数据结构决定是否采用深度监听
   3.      
      1. deep:true  开启深度监听
      2. immediate: true  初始化时让handler调用



**computeds和watch的区别:**
   1. computeds能实现的功能，watch也能实现
   2. watch实现的功能，computeds不一定能实现，比如异步操作
 重要原则:
   1. 所有Vue管理的函数，最好写成普通函数，这样this才会指向vm 或 组件实例对象
   2. 不被Vue管理的函数(定时器回调，ajax回调，Promise回调等)，最好写成箭头函数，这样this才会指向vm 或 组件实例对象


### 09_绑定样式
   1. class样式
      写法：:class="xxx"，xxx可以是字符串，数组，对象
         字符串写法适用于: 样式类名不确认，需要动态绑定
         数组写法适用于: 要绑定的样式个数不确定，类名也不确定
         对象写法适用于: 绑定的样式个数确认，类名名确认，否使用不确认
   2. style样式
      :style="{fontSize:xxx}"：xxx是动态值
      :style="[a,b]"：a，b是样式对象


### 10_条件渲染
   1. v-if
      特点: 1.可以配合v-else/v-else-if，且结构不能被打断
            2.节点直接从dom树中消失
   2. v-show
      特点: 1.节点不会消失，只是配置了display:none

      使用场景: 数据来回切换的频率高就使用v-show，不高就使用v-if


### 11_列表渲染
   <!-- 数据劫持 === 给数据添加了setter方法 -->
   Vue监视数据的原理：
      1. vue会监视data中所有层次的数据
      2. 如何监视对象中的数据？
           通过setter监视，要在创建vue实例的时候就写好data中的数据
           (1).对象中后追加的数据，vue默认不做响应式处理
           (2).如果想对后添加的数据进行响应式处理，需要使用vue提供的Vue.set(target,key,value) === vm.$set(target,key,value)
      3. 如何监视数组中的数据
           通过包装可修改原数组的方法实现,vue做了两件事
           (1).调用Array上的原方法
           (2).重新解析模板，生成新虚拟Dom，和旧的进行diff，更新页面
      4. 在Vue2中修改数组中的数据要使用一下方法:
           (1). shift()、unshift()、pop()、push()、splice()、sort()、reverse()
           (2). Vue.set()  vm.$set()


### 12_收集表单数据
   收集表单数据:
      若；<input type="text"/>，则v-model收集的是value值，用户输入的就是value值
      若；<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值
      若；<input type="checkbox"/>
         1. 没有配置value值，收集的是checked（勾选 或 不勾选，是布尔值）
         2. 若配置value值
            (1) v-model的初始值是非数组，那么收集的就是checked（勾选 或 不勾选，是布尔值，最后会将数据转换成布尔值传给checked）
            (2) v-model的初始值是数组，那么收集的就是value组成的数组
         备注: v-model的三个修饰符
            lazy: 懒更新，失去焦点才会收集信息
            number: 将默认的string类型转换成number类型
            trim: 去除字符串两边的空格


### 13_过滤器
   过滤器:
      定义: 对要显示的数据进行特定的格式化后在显示（适用于一些简单逻辑的处理）
      语法: 
          1.注册过滤器: Vue.filter(name,function)、Vue(filters:{})
          2.使用过滤器: {{xxx | 过滤器名字}} 或 v-bind:属性 = 'xxx | 过滤器名字'
      备注: 
          1.过滤器可以接受额外参数，多个过滤器可以串联
          2.不会改变原数据，是产生新的对应的数据


### 14_内置指令
   vue指令: 
      v-bind: 单向绑定解析表达式，简写 :xxx
      v-model: 双向数据绑定
      v-for: 可进行列表渲染
      v-if: 控制元素是否存在
      v-else: 控制元素是否存在
      v-show: 控制元素是否显示
      v-on: 绑定事件监听，简写@
      v-text: 替换当前节点的所有内容
      v-html: 替换当前节点的所有内容，可以识别html结构代码
      v-once: 只动态渲染一次数据（没有value值）
      v-pre: 跳过当前所在节点的编译解析过程（没有value值）
      v-cloak: 配合css使用,让未解析的模板不出现在页面上（没有value值）


### 15_自定义指令
   自定义指令总结:
      1. 定义
        （1）局部指令:
            new Vue({ directives:{指令名:配置对象} 或 directive:{指令名:回调函数} })
        （2）全局指令: 
            Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)
      2. 配置对象中常用的3个回调函数
        （1）bind: 指令跟元素绑定成功时调用
        （2）inserted: 指令所绑定的元素插入页面时调用
        （3）update: 指令所在的模板重新解析时调用
      3. 备注:
        （1）指令定义时不加v-，使用时要加v-
        （2）指令名有多个单词组成时，要用-进行分割
        （3）自定义指令中，函数的this指向的是window，不是vm


### 16_生命周期
   生命周期:
        1.又名：生命周期回调函数，生命周期函数，生命周期钩子
        2.定义：Vue在关键时刻自动调用的一些特殊名称的函数
        3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的
        4.生命周期函数中的this指向的是vm 或 组件实例对象


   1. beforeCreate: *初始化一些规则，数据代理，数据监听还没开始，但vm已经创建了*
   
   2. created: *数据代理，数据监听已经完成，vm身上已经有了数据跟方法了
   
   3. beforeMount: Vue开始解析模板，所有对dom的操作最终都不会生效，虚拟DOM在内存中*
   
   4. mounted: *Vue模板解析完成，将虚拟DOM转换成真实DOM，并挂载到页面上，所有对dom的操作都会生效。开启定时器，订阅消息，发起网络请求，绑定自定义事件等初始化操作*
   
   5. beforeUpdate: *数据已经更新完毕，只是没有跟页面保持同步*
   
   6. updated: *数据和页面保持同步*
   
   7. beforeDestroy: *可以访问data数据，调用methods的方法，但不会触发页面的更新，关闭定时器，取消订阅，解绑自定义事件*
   
   8. destroyed: *vm销毁完成*


   常用的生命周期钩子:
         1.mounted: 发送ajax请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】
         2.beforeDestroy: 清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】
   关于销毁Vue实例:
         1.销毁后Vue开发者工具上看不到任何信息
         2.Vue自定义事件会销毁，原生dom事件还会存在
         3.在beforeDestroy不会操作数据，因为操作数据也不在触发更新流程了



## 2.Vue组件化编程
- 什么是组件：实现*局部*功能*代码*和*资源*的*集合*

### 17_非单文件组件


### 18_单文件组件



## 3.使用Vue脚手架